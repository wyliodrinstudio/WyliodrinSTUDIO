<template>
	<div id="visualPanel" class="fill-height">
		<VisualAce class="shrink" v-if="show" :extension="extension" :value="visualSource"></VisualAce>
		<div ref="visual">
			
		</div>
		<v-btn class="codestatus" id="codestatus" @click="showCode">{{show?$t('EDITOR_VISUAL_HIDE_CODE'):$t('EDITOR_VISUAL_SHOW_CODE')}}</v-btn>
		<!-- <VisualAce v-if="show" :extension="'py'" v-model="pythonVisualSource"></VisualAce> -->
	</div>
</template>

<script>
import VisualAce from './VisualAce.vue';
import xml from 'xml-js';

import { mapGetters } from 'vuex';

import path from 'path';
import { setTimeout } from 'timers';

export default {
	name: 'VisualEditor',
	props: ['project', 'filename', 'active'],
	
	data ()
	{
		return {
			reload: true,
			visualSource: '',
			extension:'',
			show:false,
			workspace: null,
			source: '',
		};
	},
	computed: {
		...mapGetters ({
			currentProject: 'projects/currentProject',
			device: 'workspace/device',
			mode: 'workspace/mode'
		})
	},
	components: {
		VisualAce
	},
	methods: {
		initVisual ()
		{
			let Blockly = this.studio.editor_visual.getBlockly();
			let blocklyDiv = this.$refs.visual;

			let toolbox = this.getToolBox ();

			this.workspace = Blockly.inject(blocklyDiv, {
				media: 'plugins/projects.editor.visual/data/media/',
				toolbox: toolbox,
				zoom:
				{
					controls: true,
					wheel: true,
					startScale: 1.0,
					maxScale: 3,
					minScale: 0.3,
					scaleSpeed: 1.2},
			}
			);

			// console.log (document.getElementById('toolbox').innerHTML);
			// console.log (xml.xml2js ('<toolbar>'+document.getElementById('toolbox').innerHTML+'</toolbar>'));

			window.addEventListener('resize', this.resize, false);
			this.resize();
			// var that = this;
			this.workspace.addChangeListener (() =>
			{
				var xml = Blockly.Xml.workspaceToDom (this.workspace);
				var visual = Blockly.Xml.domToText (xml);
				this.studio.projects.saveFile (this.project, this.filename, visual);
				this.source = visual;
				this.updateSource ();
				// if (that.selectedFile && that.visual)
				// {
				// 	that.fileSource = visual;
				// 	that.pythonVisualSource = '# This file was automatically generated by the Visual language\n# You may edit it, it will be overwritten when you change the Visual language\n\n'+Blockly.Python.workspaceToCode(workspace);
				// }
				// console.log (code);
			});
			this.loadSource ();
		},
		loadSource ()
		{
			if (this.workspace)
			{
				let Blockly = this.studio.editor_visual.getBlockly ();
				this.workspace.clear ();
				if (path.extname (this.filename) === '.visual')
				{
					try
					{
						let xml = Blockly.Xml.textToDom(this.source.toString());
						Blockly.Xml.domToWorkspace(xml, this.workspace);  
					}
					catch (e)
					{
						let xml = Blockly.Xml.textToDom('<xml></xml>');
						Blockly.Xml.domToWorkspace(xml, this.workspace);
					}
				}
				this.resize ();
				this.visualsource = '';
			}
		},
		getToolBox ()
		{
			let toolbox = '<xml>';
			let toolboxes = this.studio.editor_visual.getToolboxes ();
			for (let blocks of toolboxes)
			{
				if (((blocks.type === null && blocks.board === null) 
						|| (blocks.type === this.device.type && (blocks.board === null || blocks.board === this.device.board)))
						&& blocks.visible())
				{
					for (let element of blocks.toolbox.elements)
					{
						toolbox = toolbox + xml.js2xml (element);
					}
				}
			}
			toolbox = toolbox + '</xml>';

			// let parser = new DOMParser();
			// let xmlToolbox = parser.parseFromString(toolbox,"text/xml");
			// console.log (xmlToolbox);
			return toolbox;
		},
		update ()
		{
			if (this.workspace)
			{
				this.workspace.updateToolbox (this.getToolBox());
				this.updateSource ();
			}
		},
		updateSource ()
		{
			if (this.workspace)
			{
				let Blockly = this.studio.editor_visual.getBlockly ();
				let sourceLanguage = this.studio.projects.languageSpecificOption (this.currentProject, 'sourceLanguage');
				if (sourceLanguage === 'python')
				{
					try
					{
						let visualSource = '# This file was automatically generated by the Visual language\n# You may edit it, it will be overwritten when you change the Visual language\n\n'+Blockly.Python.workspaceToCode(this.workspace);
						if (this.visualSource !== visualSource)
						{
							//this.$emit ('visual-source', visualSource);
							this.visualSource = visualSource;
							this.saveVisualSource(this.visualSource, 'py');
							this.extension = 'py';
						}
					}
					catch (e)
					{
						let visualSource = '# There was an error while generating the file:\n    '+e.message;
						//this.$emit ('visual-source', visualSource);
						this.visualSource = visualSource;
						this.saveVisualSource(this.visualSource, 'py');
						this.extension = 'py';
					}
				}
				else if (sourceLanguage === 'javascript')
				{
					try
					{
						let visualSource = '// This file was automatically generated by the Visual language\n// You may edit it, it will be overwritten when you change the Visual language\n\n'+Blockly.JavaScript.workspaceToCode(this.workspace);
						if (this.visualSource !== visualSource)
						{
							//this.$emit ('visual-source', visualSource);
							this.visualSource = visualSource;
							this.saveVisualSource(this.visualSource, 'js');
							this.extension = 'js';
						}
					}
					catch (e)
					{
						let visualSource = '// There was an error while generating the file:\n    '+e.message;
						//this.$emit ('visual-source', visualSource);
						this.visualSource = visualSource;
						this.saveVisualSource(this.visualSource, 'js');
						this.extension = 'js';
					}
				}
			}
		},
		resize ()
		{
			if (this.workspace) 
			{
				let Blockly = this.studio.editor_visual.getBlockly ();
				let visualPanel = this.$el;
				let blocklyDiv = this.$refs.visual;
				var element = visualPanel;
				var x = 0;
				var y = 0;
				do {
					x += element.offsetLeft;
					y += element.offsetTop;
					element = element.offsetParent;
				} while (element);
				// Position blocklyDiv over blocklyArea.
				blocklyDiv.style.left = x + 'px';
				blocklyDiv.style.top = y + 'px';
				blocklyDiv.style.width = visualPanel.offsetWidth + 'px';
				blocklyDiv.style.height = visualPanel.offsetHeight + 'px';
				Blockly.svgResize(this.workspace);
			}
		},
		saveVisualSource (visualSource, extension)
		{
			this.studio.projects.saveFile (this.currentProject, this.filename+'.'+extension, visualSource);
		},
		showCode()
		{
			this.show = !this.show;
			process.nextTick (this.resize);
		}
	},
	mounted ()
	{
		this.initVisual ();
	},
	destroyed ()
	{
		if (this.workspace) 
		{
			this.workspace.dispose ();
			window.removeEventListener ('resize', this.resize);
		}
	},
	watch: {
		device ()
		{
			this.update ();
		},
		filename: {
			immediate: true,
			async handler ()
			{
				// TODO queue reloads
				this.source = await this.studio.projects.loadFile (this.project, this.filename);				
				this.loadSource ();
			}
		},
		mode ()
		{
			this.resize ();
		},
		active ()
		{
			setTimeout (() => { this.resize (); this.loadSource (); }, 10);
		}
	}
};
</script>

<style lang="less">
input.blocklyHtmlInput {
	background-color: #ffffff;
}
</style>
